## Chapter 1. 使用Erlang和REST构建可扩展系统

在Web的早期，构建系统很简单。 拿一个Linux盒子，把Perl或PHP放在上面，添加Apache和MySQL，你准备好了。 当然，这个系统非常有限。 如果你想将它扩展到一两台服务器，那么它真的很难实现。 事实证明，构建可扩展的分布式应用程序很困难，而构建它们的工具往往不太理想。

在21世纪的第一个十年，谷歌，亚马逊，eBay等公司发现他们需要扩展到几台服务器，而不是几千台服务器，甚至数十万甚至数十万甚至更多。 这需要一种非常不同的思考如何构建系统的方法，并丢弃过去用于较小系统的许多模式。

提供可伸缩性，弹性和灵活性的另一个方法是使用Erlang创建站点和应用程序，前端由各种Web服务定义。

## 为何选择Erlang？

当我准备写这本书时，我向几位程序员朋友介绍了这个想法。他们都说，“我永远不会想到在Erlang中建立一个大型网站。”这可能看起来令人生畏，但Erlang的功能完全适合大规模的网络项目。

爱立信最初创建了Erlang，一种基于Prolog的功能语言，在20世纪80年代在电信交换机中运行。电信交换机必须长时间不间断地运行，这推动了Erlang中的许多选择。它的构建是为了支持必须具有容错能力且能够在不停机的情况下进行升级的系统。事实证明，这些功能不仅适用于电话交换机，也适用于关键业务Web服务。

使用Erlang的第一个主要项目之一是爱立信AXD301交换机，该交换机使用了大约一百万行Erlang代码以及一些用C语言编写的设备驱动程序和其他低级组件.AXD301交换机达到了前所未有的水平在现场的可靠性 - 在某些情况下，它已经实现了“九个9”的可靠性！可以预期系统离线的时间量为每年毫秒数。 （这适用于整个网络，而不是单个节点。）

显然，用Erlang编写的大多数系统都无法达到这种可靠性水平。通过精心设计和测试，系统可以达到6个9秒（每年约30秒的停机时间）。但是，达到这个范围超出了本书的范围，需要仔细研究可能导致系统不可用的风险，并确保没有任何单一故障（特别是超出您的代码）可能导致该故障。例如，有三个连接到互联网与不同的ISP是很好的，但如果所有三个连接通过相同的管道，只需要一个带反铲的人切断所有三条线并使系统脱机。

Erlang应用程序可以就地升级。如果应用程序在服务器群集上运行并且在一个模块中发现错误，则无需停止系统升级到新版本的软件 - Erlang提供了一种在运行时升级代码的方法，以便客户永远不需要被打断。与每次推出新版本软件时需要离线一小时或更长时间的系统相比，这是一个主要优势，因为客户无法使用该系统而花费真金白银。

Erlang还支持计算机群集。实际上，要拥有可扩展且容错的系统，它必须在多台计算机上运行。由于任何给定的计算机都可能发生故障，因此系统能够处理群集中的节点离线并仍然向客户提供服务的情况非常重要。系统应运行多少个节点是一个复杂的问题，但它首先提出的问题是“在将新节点联机之前，所有剩余节点出现故障的概率是多少？”

> Note: 如果您使用Google“Erlang”，您将看到对“Erlang-B”和“Erlang-C”的引用。 这些是电话容量的衡量标准，如果您正在建立呼叫中心，但与编程语言无关，则可能非常重要。

## Erlang的优势

Erlang做了很多不同的事情。在大多数编程语言中，并发性是事后的想法。例如，PHP中的每个进程都独立运行，并且通常仅通过外部资源（如数据库或memcached服务器）与其他PHP进程通信。在Erlang中，并发性是从系统的基础构建的。

另一个区别是Erlang是一种编译语言。在PHP中，您只需编辑文件并转到Web服务器，它将运行新版本。在Erlang中，您需要编译代码并将其加载到系统中，虽然这并不困难，但它确实代表了一个额外的步骤。

对于一个新的Erlang程序员来说，Erlang最奇怪的事情是所有变量都是单一赋值。用Java术语来说，好像所有变量都是最终的。这需要一些时间来适应，但实际上在并发处理正常的语言中非常强大。如果永远不能更改变量，那么锁几乎成为一个无关紧要的细节。另一个优点是单个赋值变量只能在一个地方分配其值，因此如果它具有错误的值，那么确定该值的来源变得容易得多：它必须在初始赋值时设置。

Erlang具有并发的消息传递模型，因此线程之间没有共享状态 - 消除了程序员在代码中设置锁的需要。如果你需要共享状态，你可以通过Mnesia数据库（参见[Mnesia](https://www.safaribooksonline.com/library/view/Building+Web+Applications+with+Erlang/9781449320621/ch01.html#mnesia)）来实现，Mnesia支持事务和锁，实际上提供了一种软件事务内存（STM）共享内存。

Erlang的进程是语言的一个特性，而不是操作系统。 Erlang进程的重量比类似的OS进程轻得多。 Erlang中的进程通过发送消息来相互通信，这些消息通常具有非常低的开销，但如果在进程之间复制大量数据，则可能很重。

> Note: 除非另有说明，否则本书中的“进程”指的是Erlang进程，而不是OS进程。 Erlang的流程非常轻巧，具有非常快的切换和启动时间。

## 缺乏类型

Erlang因其缺乏类型系统而受到批评，而Erlang确实没有像Haskell那样的静态类型。类型系统为程序员提供了一种方法来证明程序在处理数据方面是一致的。但是，在像Erlang这样的分布式系统中，提供这种静态一致性会产生一些实际成本。

Erlang允许您在保持系统运行的同时升级系统。但是，通过执行此操作，您将创建一个不一致的系统。如果在版本更改中更改了类型（并且可以合理地假设大多数版本更改将涉及更改类型），则要求静态类型意味着运行旧版本的节点无法与运行新版本的节点通信 - 并且与内部流程相同同一个节点。

想象一下，系统中只有两个节点，都运行相同版本的某些软件。这是一个一致的系统，其中一致性是类型定义之一。但是，当需要升级系统时，一个节点运行新软件并且另一个节点运行旧软件会有一段时间。此时，您在类型方面存在不一致的系统。

此时您有几个选择。如果您在Haskell中构建了系统，则可能需要一个分区，在该分区中运行旧版本软件的节点无法与运行新版本的节点通信。您还可以在升级时将系统暂时关闭一段时间，从而牺牲系统的可用性，但确保系统在运行时从不进行分区且永不矛盾。

这个问题没有一般的完美解决方案。 Erlang的构建旨在优化最大可用性，因为选择是为了使其在某些方面不一致，同时仍然提供服务。实际上可能在Haskell中解决这个问题，但到目前为止还没有人这样做过。 Erlang的构建假设错误将会发生，并且系统应该有持续处理它们的方法。 Haskell旨在最大限度地减少错误，周期。不同的优先级导致不同的设计。

## OTP-不仅仅是电信！

用于构建容错应用程序的开放式电信平台（OTP）框架随Erlang一起提供。通过将软件设置为在OTP框架内运行，应用程序可以利用OTP的内置故障恢复和监控功能。 OTP自动化了Erlang的大部分并发性，但真正让它大放异彩的是它能够监视正在运行的应用程序并使其保持运行。

与许多其他语言中的try/catch块不同，Erlang代码采用“let it crash”的方法。 Erlang认为，当出现问题时，让它出错，并且不要试图在未知状态下将它重新粘贴在一起。 OTP将重启被监控的受监控进程。这样做的好处是，已经死亡的节点上的进程可以在其他地方重新启动。 （显然，如果它所在的服务器已经死亡，节点就无法自行修复。）如果您想要一个可以容错的系统并继续提供服务，那么您需要一个可以处理故障并简单解决它的框架。

本书在[第9章](https://www.safaribooksonline.com/library/view/Building+Web+Applications+with+Erlang/9781449320621/ch09.html)中使用OTP构建了一个应用程序;但是，这不是对该主题的完整介绍，因为我仅涵盖编写此特定应用程序所需的元素。 Erlang编程和编程Erlang都提供了更详细的介绍，而Erlang和OTP in Action在OTP上有更详细的介绍。

## 为何选择Web服务？ 为何选择REST？

多年的Web工作使人们对特定URL与特定资源相关联的想法感到满意。例如，URL http://en.wikipedia.org/wiki/Erlang_(programming_language）是Erlang上的Wikipedia页面。在这种情况下，显而易见的是URL如何与底层资源相关。对于想要由具有Web浏览器的人阅读的网页，这是一种有用的表示。

在REST浮出水面之前，开发人员通过仔细研究HTTP成功的方式和原因，创建了许多方法来通过网络发送远程过程调用。当HTTP成为互联网通信的主要机制时，许多相同的机制被重新用于通过HTTP运行。这很广泛，因为HTTP工具很常见，但并不总是利用HTTP的优势。

在REST之前，人们倾向于通过SOAP隧道服务。但是，SOAP没有很好地利用HTTP - 它只通过HTTP POST请求来回发送XML消息。除了HTTP经常通过防火墙的能力之外，它不利用HTTP基础结构的缓存代理或其他功能。

REST利用HTTP的一组有限的请求动词并生活在对其处理的期望中，从而更好地利用了HTTP。这迫使在无限数量的可能资源上采用有限数量的动作。它需要一些时间来习惯，但它提供了一种通过网络发送信息的一致且强大的方式，可以轻松地与Web基础结构和接口集成。

> Note: 有关REST服务应如何工作的完整详细信息，请参阅Webber，Parastatidis和Robinson（http://restinpractice.com）中的REST in Practice。

REST将URL（通常称为统一资源标识符（URI））视为处理底层资源的基本方法。此外，资源可能有多种表示形式;例如，电子书可以作为PDF，mobi或其他格式访问。

在RESTful服务中，四个HTTP动词GET，POST，PUT和DELETE具有明确定义的含义。 GET请求应该只检索信息。 GET也应该是幂等的：客户端可以根据需要多次调用它，并且它不会以客户端关心的任何方式更改系统的状态。 （例如，它可能会向日志添加信息，但不会更改面向用户的数据。）只要服务器设置ETag或Cache-Control标头，这使代理服务器或客户端可以轻松缓存资源，允许更快地响应网络上的读取。 （HEAD和OPTIONS请求，如果您使用它们，也应该是幂等的。）

POST方法将创建一个新实体，它可以是聊天室或数据库中的记录。 PUT方法将用新版本替换资源。这可以用于更新记录等。 DELETE方法用于删除资源。

REST定义DELETE和PUT方法，以便它们可重复。也就是说，多次调用它们会对系统产生与调用它们一样的效果。例如，如果您在资源上调用一次或四次DELETE，它仍应具有删除资源的最终结果（或生成错误）。

在RESTful服务中，URL应该可靠地用于标识要处理的资源。在许多方面，您需要首先通过识别资源来构建，然后确定交互如何构建应用程序。

## 扩展和恢复的新机遇

Erlang和RESTful Web服务可以更好地了解最近的技术变化，从而更容易应用Erlang的优势。

### 云计算

云计算，至少在“基础架构即服务”（IaaS）模型上，使得向网络添加新服务器变得简单快捷。 在预云系统中，添加新服务器需要订购，转发到数据中心，并将其物理安装在机架中。 大多数云设置都会将其减少为可以在一两分钟内启动服务器的REST API。

这完美地补充了Erlang。 Erlang具有许多功能，允许网络系统实时添加节点并检测它们何时出现故障。 当然，如何在云中设置Erlang应用程序的细节将在很大程度上取决于应用程序的细节以及预期获得的加载类型。

> Note: 在IaaS云实施中，该服务提供虚拟平台，每个平台都运行完整的操作系统。 用于可能是某种形式的Linux的Erlang，但也可能是Windows或其他操作系统。

Erlang提供了一个名为erlang:monitor_node/2的内置函数（BIF），如果有问题的节点脱机，它将发送{nodedown，Node}形式的消息。在这种情况下，让监控过程使用来自AWS或其他云提供商的REST API来自动启动新节点会很简单。如果系统过载，系统也可以启动新节点。

有两次系统可能希望调出一个或多个节点。第一种是当节点发生故障时，系统会调出一个新节点来替换它。第二个是当一组节点过载时。这当然需要一些系统监控。但是如果一个系统足够聪明，知道一组节点上的平均系统负载正在增加，那么系统可以设置为创建新节点并将它们链接到系统，而不是崩溃并让管理员稍后处理它。系统。有关如何执行此操作的详细信息将取决于托管服务提供商和应用程序的需求。

包含一个覆盖自动系统的选项并允许管理员手动设置多个服务器可能也很聪明。例如，如果您的公司要在超级碗中运行广告，那么在广告投放和系统过载之前有足够的服务器运行并准备就绪是有意义的。

除了向外扩展之外，还存在在系统具有比所需节点更多的节点期间缩小的问题。您的系统可能已经运行了多达300个节点来处理来自超级碗广告的负载，但现在它已经结束了它可以缩放到较低级别。这对于在开发中的测试机器上运行应用程序也很有用。

### 系统架构和Erlang扩展

从大约1970年到2002年左右，系统处理器变得更快，每18个月左右速度加倍。然而，2002年左右的某些地方发生了变化。随着速度越来越快，物理定律在这一进步中崭露头角。更快的速度会产生更多的热量，这会消耗更多的能量并导致更多的废热问题。此外，光速会对信号在一个时钟周期内的传播距离产生严格限制。因此，自2002年以来，趋势不是使处理器更快，而是将更多的处理器放在每个芯片上。

当CPU变得越来越快时，加速代码变得非常容易。如果你只等了18个月并且没有做任何事情，你的程序会快两倍！在多核处理器时代，这已不再适用。现在程序员需要编写将使用系统上所有内核的程序。在一个六核芯片上，顺序程序可以在一个核心上运行全程，但其他五个正在无所事事。

截至2011年秋季，英特尔的高端服务器芯片有8个核心，英特尔的消费者芯片有多达6个核心（在许多情况下，每个核心可以运行两个线程），AMD已宣布推出一系列处理器有八个核心。 IBM的Power7芯片有八个内核，每个内核运行四个线程。期望在几年内我们将谈论具有32,64甚至128个核心或更多核心的芯片并不是疯狂的。我们为这些处理器编写程序的方式将与我们为过去的单处理器芯片编写程序的方式不同。目前尚不清楚Erlang是否会扩展到64或128个核心，但它可能比大多数其他语言更有机会。

如果要有效地使用多核芯片，则需要准备好运行大量进程。理想情况下，进程数应远大于芯片数量，以简化分发。如果CPU上运行了16个处理器线程，那么只有16个或32个进程可能无法正常工作，因为从统计上来说，需要有一个等待运行的处理器池，以便永远不会阻止所有进程。当进程在磁盘或网络等上等待时，芯片不会做任何事情。等待大量进程意味着当一个进程进入等待状态时，系统总是可以在队列中拥有任务。

假设在进程之间切换的时间非常短（对于Erlang进程来说是这样），那么拥有数千个进程或更多进程将是最好的，因此系统可以确保始终有进程进入等待核心的进程。

像Erlang这样的系统能够很好地扩展的能力取决于三个方面：进程开始的速度，系统在它们之间切换的速度，以及传递消息的成本。 Erlang做得很好，最大限度地减少了这三个因素。

### 缩放与缩小

扩展系统有两种基本方法：向上或向外。 扩展系统意味着用更大的服务器替换服务器 - 你取出现有服务器并添加一个具有更多CPU，更多内存，更多磁盘等的服务器。然而，这有限制，而且它可能很昂贵。 IBM的顶级服务器可以拥有多达32个CPU，同时运行1024个处理器线程。 然而，在网络规模上，这看起来仍然很小。

扩展系统意味着将其分布在许多较小的服务器上。 因此，您不需要购买价值数百万美元的IBM Power7服务器，而是购买一堆英特尔级服务器，并将这些服务器分散开来。 这样做的好处是，如果设置正确，除了预算之外没有其可以扩展的范围。 当与今天的基于云的PaaS平台一起使用时，通过从AWS或其他云提供商订购更多服务器，可以在几分钟内扩展意外负载。

### 阿姆达尔定律

Gene Amdahl是一位计算机架构师，最初因为从20世纪50年代到80年代为IBM和其他人设计大型机而闻名。他提出了一个关于系统性质的强烈论据，其中某些部分是平行的，而其他部分则不是。

被称为Amdahl定律的论证指出，在一个系统中，部分过程是顺序的，而其他部分是并行的，那么总加速量永远不会超过顺序部分 - 增加更多核心将无法实现整体系统走得更快。 （有关Amdahl定律的完整解释，请参阅该主题的维基百科页面：http://en.wikipedia.org/wiki/Amdahl%27s_law。）

作为类比，想象一下，你去了一家银行，那里有一堆柜员，但只有一台现金点钞机。随着越来越多的客户进来，经理可以随时添加更多的柜员，但如果他们必须排队使用现金柜台，系统将永远不会变得更快。

在任何应用程序中，总会存在顺序的部分。在Erlang应用程序中，我想到了一些地方。模块设置和拆卸代码是顺序的，但由于它通常仅在新服务联机时运行，因此可能不是瓶颈的主要来源。

顺序资源使用可能成为问题的一个地方是访问磁盘。根据定义，磁盘是顺序的，因为给定的磁盘一次只能读取或写入一个东西。磁盘通常也比内存或CPU缓存慢几个数量级。将数据写入磁盘或记录模块的数据存储等组件通常是可能发生整个系统瓶颈的地方。

另一个可能导致大量顺序代码的地方是锁。一般来说，这在Erlang中不像Java或C＃那样是一个问题，但至少在理论上，如果事情被阻塞等待事务，它可能是Mnesia或类似工具的问题。

### 数据存储选项

回到1998年至2005年的“旧时代”，开发Web服务时的数据存储选项是SQL数据库的选择。 MySQL始终是最简单的选择;其他选项包括Postgres，Oracle和Microsoft SQL Server。所有这些产品都是SQL数据库，其中包含SQL内置的所有优点和缺点。

SQL数据库对很多东西都很好，但在水平扩展方面却非常糟糕。尝试在大多数SQL数据库中构建分区数据库或多主机设置充其量是一个主要的痛苦，在最坏的情况下是最困难的。如果为项目选择了Erlang和Yaws，目标是使服务具有容错性和可扩展性，那么当然这些属性也必须存在于数据存储解决方案中。

在现代，许多Web开发项目正在转向“NoSQL”，这是一组松散定义的数据存储技术，用于处理Web规模的数据。 NoSQL的好处在于，在数据存储方式方面还有比SQL更多的选择。不好的是，由于还有更多选择，开发应用程序的团队必须准备好了解这些选择并选择最有效的系统或系统。

NoSQL解决方案缺少程序员已经习惯的一些SQL功能。首先要注意的是，大多数NoSQL数据存储都不知道连接。尝试跨多个主机连接两个表是一个有问题的任务，需要使用MapReduce技术或类似的东西进行多个搜索和连接阶段。

> NOTE: 有关SQL和NoSQL数据库的概述，请参阅Eric Redmond和Jim R. Wilson撰写的七周七数据库一书（实用程序员：http://pragprog.com/book/rwdata/seven-databases-in-seven-weeks）。 本书讨论了PostgreSQL，Riak，Redis，HBase，MongoDB，CouchDB和Neo4j。

许多NoSQL数据存储也缺乏任何事务概念。确保一致性取决于程序员。同样，这源于数据存储的分布式特性。尝试确保跨多个主机的所有数据始终保持不变通常可以是O(N)或甚至O(N^2)任务。因此，开发人员需要确保数据操作以合理的方式工作。

从SQL迁移到NoSQL时要注意的另一件事是找到多年来一直在做SQL的开发人员和系统管理员相对容易。围绕SQL的知识基础尚未围绕NoSQL开发，这仍然很年轻。可以肯定地说，从现在起10年后，SQL数据库看起来与它们今天的方式类似，而NoSQL仍然有很多进化，因为它是一个新的产品系列。

为了容错，数据库（如应用程序服务器）必须能够扩展到多台计算机，并能够处理服务器死亡的情况。此外，为了可扩展，每个服务器必须是独立的。如果有三个节点，群集每分钟可以提供N个请求，那么对于六个节点，它应该能够每分钟（或至少关闭）提供2N个请求。实际上，这通常是不可能的，因为对共享资源的争用将会受到阻碍。真正的线性缩放是理论上最好的情况。

> CAP 定理
```
CAP定理是Eric Brewer提出的一个想法，它表明分布式计算机系统不可能同时对所有三个一致性，可用性和分区容差提供严格的保证。事实上，这个定理在数学上已被证明是正确的。谷歌搜索将为可能感兴趣的人揭示证据的全部细节。

一致的系统是所有节点始终看到相同数据的系统。传统上，这在单节点系统或在少量节点上运行的系统中都可见。大多数SQL数据库在事务等方面具有广泛的功能，以确保数据在任何给定时间始终保持一致，并且在某些情况下这是一个重要特性。

可以在大规模并发系统上实现一致性;但是，必须以容错或可用性为代价。在某些情况下，实现这一目标的成本可能非常高。此外，如果所有节点必须就数据状态达成一致，这可能会使处理失败变得更加困难，因为节点可能会脱机。

完全一致的系统的问题在于，当扩展到许多节点时，通信开销可能变得非常高。每个节点必须始终就数据状态的所有方面达成一致。这会使扩展系统变得困难，因为两阶段提交会导致越来越多的锁通过系统传播。

但是，完全一致性通常不像人们想象的那么重要。在许多网络规模的应用程序中，如果某些用户在其他用户之后几秒钟看到新数据，则无关紧要 - 例如，如果我向eBay发布新的拍卖，如果某些用户没有看到它，那就不是非常重要了一两分钟。另一方面，在某些银行系统中，这将非常重要。

可用系统是所有客户端始终可以读写数据的系统。显然，拥有一个可用性保证的系统是一件好事;但是，不可能将其与分区容差和恒定性相结合。如果系统在面对网络拆分时必须完全保持不变，则必须禁止写入，因为它无法确保所有节点上的数据一致。

分区容错数据库的最佳示例是DNS系统。 DNS系统几乎总是可用的，但有些服务器可能在任何给定时间与其他服务器分开，在这种情况下，它们将提供旧数据，直到问题得到解决。因此，网络上的所有用户将始终能够使用DNS系统，但可能并不总是看到给定查询的相同数据。

CAP定理主要是在数据库方面提出的，但实际上它适用于任何分布式计算系统。例如，Git和Mercurial版本控制往往是AP系统，而CSV和Subversion往往是CA系统。像Git和Mercurial这样的系统也需要明确处理必须合并两组更改的情况。

事实上，CAP定理适用于许多可能不明显的领域。例如，外汇是一种广泛可用的系统，并不总是完全一致。世界各地交易所的报价通常都是相似的，但可能略有不同，因为信号需要时间在伦敦和纽约之间旅行，100％的一致性实际上是不可能的。

根据定义，Erlang系统是分布式的，因此CAP不仅适用于数据存储，还适用于整个系统。理解这个想法是在分布式环境中构建成功应用程序的关键。
```

### Mnesia

Mnesia是Erlang自己的数据库。 它是一个非常快速的数据存储，旨在与Erlang配合使用，它有几个很好的优点。 它适用于本机Erlang记录和代码，也可以将其设置为从RAM或磁盘提供数据并跨节点镜像数据。 您甚至可以对其进行设置，使数据在大多数节点上存储在内存中，但在一个或两个节点上镜像到磁盘，以便所有访问都在内存中以实现非常快速的操作，但所有内容都写入磁盘以实现长期持久性。

> Note: 从技术上讲，Mnesia数据存储是ETS和DETS。 Mnesia是一个基于它们构建的事务和分发层。

Mnesia的一个可能问题是，虽然它不是SQL数据库，但它是一个像SQL数据库一样的CA数据库。它不会处理网络分区。这并不意味着它在可伸缩的应用程序中不可用，但它将与MySQL等SQL数据库有许多相同的问题。

Mnesia内置于Erlang中，因此无需安装。但是，它必须在Yaws启动时启动。为此，请使用OTP函数application:start(mnesia)。启动Mnesia数据库。从这里开始，可以使用mnesia:create_table/2函数创建表，该函数使用Erlang记录作为其表模式。有关如何使用Mnesia的完整详细信息，请参阅一些Erlang参考。 Erlang文档还包括Mnesia上的一组手册页。

通过使用qlc模块，还可以将Mnesia表视为一个大数组，因此您可以使用Erlang的数组推导将数据从Mnesia中提取出来。甚至可以执行诸如foldl之类的操作来汇总表中的数据。

### COUCHDB

CouchDB是一个实际用Erlang编写的数据存储。与Mnesia和MySQL不同，CouchDB不是围绕具有固定模式的记录组织的;相反，它是一个文档存储，从Lotus Notes中获取一些想法。事实上，创建CouchDB的Damien Katz过去常常使用Lotus Notes。

CouchDB还为最终的一致性放弃了严格的一致性。通过这样做，它可以创建分区容错和可用性的保证。在CouchDB网络中，每个节点都可以是主节点，即使两个节点没有通信，也可以更新两个节点。

缺乏一致性会产生一些成本，但它也有一些主要的好处。在许多情况下，确保所有节点始终就数据状态达成一致是一项非常昂贵的操作，可能会在大型系统上产生大量负载。

从Erlang到CouchDB有多个接口，包括couchbeam，eCouch，erlCouch和erlang_couchdb。其中每个都提供了一些不同的功能，但其中一些（包括couchbeam和eCouch）作为OTP应用程序运行。所有这些链接都可以在CouchDB wiki上找到：http://wiki.apache.org/couchdb/Getting_started_with_Erlang。

### MONGODB

MongoDB也是一个NoSQL数据库，但它旨在假设一个具有分区容错性的数据库，并且能够轻松共享数据。 可以使用https://bitbucket.org/rumataestor/emongo提供的emongo驱动程序从Erlang访问MongoDB。 该API非常简单，并在网站上有记录。

### REDIS

Redis也是一个关键的价值数据存储，但与MongoDB和CouchDB不同，Redis通常将其整个数据集保存在内存中以实现非常快速的访问，同时在磁盘上保留某种形式的日志，以便它在服务器重新启动时仍然是持久的。 像Mongo一样，它是一个CP数据存储。

在Erlang，Erldis和Eredis中有两套Redis驱动程序，这两个驱动程序都可以在Redis主页http://redis.io上找到。

### RIAK

Riak是另一个文档数据库，在某些方面类似于CouchDB。与CouchDB一样，它是用Erlang编写的，并且在可用性，可伸缩性和分区容错方面放弃了严格的一致性。它意味着是一个分布式系统，并且通过添加节点来提供扩展的良好支持，并通过删除不再需要的节点来缩小。 Riak可以在http://www.basho.com找到。

Riak在很大程度上源自亚马逊的Dynamo数据库。这个想法是你通过一致的散列环分割许多节点，并且数据库中的任何密钥都被发送到负责环的给定部分的节点。

关于可用性的好处是节点以可能允许仲裁系统的方式拆分。也就是说，在N个节点的系统中，为了使写入成功，所有节点必须同意该事务。这是一个完全一致的系统，可用性较低。如果只有节点的某些子集（M）需要达成一致，那么只有集群的一个子集必须响应才能工作。

通过调整 M:N 的比率，可以根据一致性水平与期望的可用性来调整系统。可以基于每个查询设置此调整，因此系统非常灵活。

由于Riak主要使用Erlang编写，因此可以很好地支持Riak与Erlang应用程序的接口。



